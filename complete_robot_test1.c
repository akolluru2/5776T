#pragma config(Sensor, in1,    lift,           sensorPotentiometer)
#pragma config(Motor,  port1,           TLDM,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LiftLeftNormal, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LiftLeftYCable, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           BLDM,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           IntakeLeft,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           IntakeRight,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           BRDM,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LiftRightNormal, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           LiftRightYCable, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          TRDM,          tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define C1LX vexRT[Ch4]
#define C1LY vexRT[Ch3]
#define C1RX vexRT[Ch1]

//desired rate is units of 2000 pot ticks per second, so in code the value used is 200;
int desired_descent_rate = 1;
int holding_power = -127;
int liftSpeed = 127;
bool holding_claw = false;
bool controlled_fall = true;
int pv;
float last_pot_val;
float current_pot_val;
float extreme_pot_val = 1750;
float minor_extreme_pot_val = 2450;

void power_lift(float power){
	motor[LiftLeftYCable] = motor[LiftLeftNormal] = power;
	motor[LiftRightYCable] = motor[LiftRightNormal] = -1 * power;
}

void jank_fall() {
	//jank method
	int p = 0;
	pv = SensorValue(lift);
	if(pv < extreme_pot_val){
		p = -100;
	}
	else if(pv < extreme_pot_val + 100 * 1){
		p = -60;
	}
	else if(pv < extreme_pot_val + 100 * 7){
		p = -30;
	}
	else if(pv < extreme_pot_val + 100 * 3){
		p = -20;
	}
	else if(pv < extreme_pot_val + 100 * 4){
		p = 0;
	}
	else if(pv < extreme_pot_val + 100 * 27){
		p = 6;
	}
	else if(pv < extreme_pot_val + 100 * 33){
		p = 10;
	}
	else if(pv < extreme_pot_val + 100 * 27){
		p = 20;
	}
	else if(pv < extreme_pot_val + 100 * 19){
		p = 30;
	}
	else if(pv < extreme_pot_val + 100 * 23){
		p = 20;
	}
	power_lift(p);
}

task velocity_controlled_liftdown(){
	current_pot_val = SensorValue(lift);
	int p = 50;
	float rate_c = 0.06;
	float rate_error = 0;
	float accumulated_rate_error = 0;
	float previous_rate_error = 0;
	int dt = 1;
	while(true){



		last_pot_val = current_pot_val;
		wait1Msec(dt);
		current_pot_val = SensorValue(lift);
		float current_rate = ((current_pot_val-last_pot_val)/dt);

		//if(current_pot_val > 3600){
		//	rate_c = 0;
		//	} else {
		rate_c = 0.001;
		//}

		//if(current_rate > rate_c - 0.03){
		previous_rate_error = rate_error;
		rate_error = current_rate - rate_c;
		accumulated_rate_error += rate_error;
		p += (rate_error) * 0.005 * 127;
		p += accumulated_rate_error * 0;
		p += (rate_error - previous_rate_error) * 3;
		//}
		//else{
		//p = 0;
		//}
		if(vexRT(Btn8D) == 1){
			writeDebugStream("df: %d",current_pot_val-last_pot_val);
			if(SensorValue(lift) < extreme_pot_val){
				power_lift(-127);
				} else if(SensorValue(lift) < minor_extreme_pot_val){
				power_lift(-70);
				} else {
				power_lift(p);
			}


		}
		else {
			if(vexRT(Btn8U) == 0 && controlled_fall == true){
				power_lift(p);
			}
		}
	}
}
task main()
{
	//startTask(velocity_controlled_liftdown);
	while(true){
		//Drive
		motor[TLDM] = -C1LY - C1LX - C1RX;
		motor[TRDM] =  C1LY - C1LX - C1RX;
		motor[BRDM] =  C1LY + C1LX - C1RX;
		motor[BLDM] = -C1LY + C1LX - C1RX;
		wait1Msec(20);

		//Lift
		if (vexRT[Btn8U] == 1){
			power_lift(liftSpeed);
			}else if (vexRT[Btn8D] == 1){

			/*
			//non-velocity-pid method
			last_pot_val = current_pot_val;
			current_pot_val = SensorValue(lift);
			if(current_pot_val < extreme_pot_val) {
			power_lift(-127);
			} else {
			int p = -50 + (50 * ((current_pot_val - extreme_pot_val)/2000));
			power_lift(p);
			}*/
			/* if pot value = extreme
			then - 127
			if in mid range
			then use pot value to range power
			if near end aka close to the ground
			then use ???
			*/


			//velocity-pid-method
			jank_fall();


			}else{
			if(controlled_fall == false){
				motor[LiftLeftYCable] = motor[LiftLeftNormal] = 0;
				motor[LiftRightYCable] = motor[LiftRightNormal] = 0;
			}
			else {
				jank_fall();
			}
		}


		//Intake
		if (vexRT[Btn8L] == 1){
			motor[IntakeLeft] = motor [IntakeRight] = 127;//Intake open mapped to 7L
			}else if (vexRT[Btn8R] == 1){
			motor[IntakeLeft] = motor[IntakeRight] = -127;//Intake close mapped to 7R
			}else if (holding_claw == false){
			motor[IntakeLeft] = motor[IntakeRight] = 0;
		}

		//Holding function for claw
		//To stop holding function press 8L or 8R
		if (vexRT[Btn7L] == 1){
			if (holding_claw == false){
				holding_claw = true;
				motor[IntakeLeft] = motor[IntakeRight] = holding_power;
			}

		}
		if((vexRT[Btn8L] == 1 || vexRT[Btn8R] == 1) && holding_claw == true){
			motor[IntakeLeft] = motor[IntakeRight] = 0;
			holding_claw = false;
		}/*else {
		if(holding_claw == false){
		motor[IntakeLeft] = motor[IntakeRight] = 0;
		}*/

	}
}
